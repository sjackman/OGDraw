##########################################################
#                     Linear.pm                          #
##########################################################
#  Module to create linear maps from GeneBank files or   #
# entries                                                #
#                                                        #
# Authors:                                               #
# Marc Lohse and Oliver Drechsel                         #
# Max-Planck-Institute of molecular                      #
# plant physiology                                       #
# Am Muehlenberg 1                                       #
# 14476 Potsdam-Golm                                     #
# lohse@mpimp-golm.mpg.de                                #
# drechsel@mpimp-golm.mpg.de                             #
#                                                        #
##########################################################

=head1 Name

GeneMap::Linear
Create high quality linear maps of linear sequences from Genbank files or
accession numbers
This module depends on GeneMap::Plastome and GeneMap::Chondriome.

=head1 Synopsis


 use GeneMap::Linear;

 # create a new Linear object
 my $p = GeneMap::Linear->new(	accnum  => 'Z00044', # tobacco 2006 version in NCBI Database
 				file       => "Z00044.gb", #use either file OR accnum
                                        IRAstart   => 86687,
                                        IRAend     => 112027,
                                        IRBstart   => 130599,
                                        IRBend     => 155939,
					Xsize	   => 1200,
                                        gc_cont    => 0)


 # autodetect inverted repeat borders and include them in the map
 # this requires the small irscan tool to be installed in your PATH
 $p->findIRborders();

 $p->setZoomRange(	start	=> 5000,
			end 	=> 17500)

 # create map and write to PostScript file 
 # available types are tif, jpg, gif, png 
 $p->createMap(outputfile => "plastome.ps", type => 'ps'); 


 # list all feature types in the GenBank entry (or file, if provided)
 my @types = $p->getFeatureTypes();
 print "types found in \$p: @types\n";

 # you want to see a feature, that is not drawn by standard?
 # this feature type will now be drawn if you invoke ->createMap again
 $p->setDrawFlag(featureID => 'unclassified', drawflag => 1);

 # add new feature type to the list of features that will we included in the map
 $p->addDrawableFeature(
					type => 'gene',
					pattern => '.*',
					color => [171,200, 157],
					fullname => 'any gene',	
					drawflag => 1
					);

=head1 Description

This module provides an easy way to generate publication-quality maps in a flexible way. It can be used to depict linear molecules or parts (zoomed) of circular molecules. Since it's using the Image::Magick wrapper module you can export the created map in any image format that is supported by ImageMagick or use the PostScript file that is generated by default. We have also set up a website that is using the Plastome module - users are advised to make use of this site since any new (debugged) versions of the module will be at work there: 

L<http://ogdraw.mpimp-golm.mpg.de>

=cut

package GeneMap::Linear;

#
# include modules
#

use strict;
use GeneMap::Plastome;
use GeneMap::Plastome::ToolBox;

use Data::Dumper;

use vars qw/@ISA/;

@ISA = qw/GeneMap::Plastome/;

#
# constants
#

use constant BLACK  => 0,   0,   0;
use constant WHITE  => 255, 255, 255;
use constant RED    => 255, 0,   0;
use constant GREEN  => 0,   255, 0;
use constant BLUE   => 0,   0,   255;
use constant ATP    => 151, 190, 13;
use constant PSA    => 0,   102, 44;
use constant PSB    => 50,  137, 37;
use constant RBCL   => 31,  161, 45;
use constant PET    => 121, 156, 19;
use constant TRN    => 22,  41,  131;
use constant ORF    => 87,  185, 168;
use constant NDH    => 255, 236, 0;
use constant CLP    => 233, 93,  15;
use constant RRN    => 226, 0,   26;
use constant RPO    => 189, 18,  32;
use constant RPS    => 219, 170, 115;
use constant RPL    => 158, 119, 66;
use constant YCF    => 255, 250, 208;
use constant ORI    => 255, 128, 128;
use constant VIOLET => 171, 37,  157;
use constant DARK_RED => 127,  0,  0;
use constant RE_LINE_COLOR => 255, 175, 175;

use constant PS_X_SIZE          	=> 1200; # default X size of the PostScript object
use constant PS_Y_SIZE          	=> 600; # default Y size of the PostScript object 
use constant PS_DRAWABLE_SIZE		=> 1180; # availbale PS pixels for map
use constant CHAR_HEIGHT			=> 8; # Character height - - has to be checked again -- checked
use constant DIRECT_LABEL_POS		=> PS_Y_SIZE * 0.5 + 35; # Y position of unshifted direct strand labels
use constant DIRECT_LABEL_POS_SHIFT	=> PS_Y_SIZE * 0.5 + 80; # Y position of shifted direct strand labels
use constant COMP_LABEL_POS			=> PS_Y_SIZE * 0.5 - 35 - CHAR_HEIGHT; # Y position of unshifted complementary strand labels
use constant COMP_LABEL_POS_SHIFT	=> PS_Y_SIZE * 0.5 - 80; # Y position of shifted complementary strand labels
use constant OPT_LABEL_SHIFT		=> 20; # amount of pixel to shift labels during optimization
use constant MAX_GENE_SIZE     		=> 10000; # maximal sensible gene size. required to identify annotation monsters
use constant MIN_SPLIT_SIZE     	=> 3500; # smaller genes will not be split into sublocations
use constant STRING_WIDTH_SCALING 	=> 0.9; # factor for scaling the string width calculation routine
use constant OPERON_WIDTH       	=> 7.5;
use constant OPERON_COLOR			=> RED;
use constant TRUE 		        	=> 1;    # quite "unperlish" but improves the readability (at least for me)
use constant FALSE              	=> undef();# was 0
use constant RE_Y_POSITION			=> PS_Y_SIZE * 0.5 + 120; 




# common template for the drawable features list
our @drawable_features = 
(
{type => 'gene', 	pattern => '^psa.*', 			color => [PSA],		fullname => 'photosystem I', 			drawflag => TRUE},
{type => 'gene', 	pattern => '^psb.*',			color => [PSB],		fullname => 'photosystem II', 			drawflag => TRUE},
{type => 'gene', 	pattern => '^pet.*',			color => [PET],		fullname => 'cytochrome b/f complex', 	drawflag => TRUE},
{type => 'gene', 	pattern => '^atp.*', 			color => [ATP],		fullname => 'ATP synthase', 			drawflag => TRUE},
{type => 'gene', 	pattern => '^ndh.*',			color => [NDH],		fullname => 'NADH dehydrogenase', 		drawflag => TRUE},
{type => 'gene', 	pattern => '^rbcl.*', 			color => [RBCL],	fullname => 'RubisCO large subunit', 	drawflag => TRUE},
{type => 'gene', 	pattern => '^rpo.*',			color => [RPO],		fullname => 'RNA polymerase', 			drawflag => TRUE},
{type => 'gene',	pattern => '^rps.*',			color => [RPS],		fullname => 'ribosomal proteins (SSU)', drawflag => TRUE},
{type => 'gene', 	pattern => '^rpl.*',			color => [RPL],		fullname => 'ribosomal proteins (LSU)', drawflag => TRUE},
{type => 'gene', 	pattern => '(^clp.*)|(^mat.*)',	color => [CLP],		fullname => 'clpP, matK', 				drawflag => TRUE},
{type => 'other', 	pattern => '.*',				color => [VIOLET],	fullname => 'other genes', 				drawflag => TRUE},
{type => 'CDS|gene',pattern => '^ycf.*', 			color => [YCF],		fullname => 'hypothetical chloroplast reading frames (ycf)', drawflag => TRUE},
{type => 'gene',pattern => '^orf.*',			color => [ORF],		fullname => 'ORFs', 					drawflag => TRUE},
{type => 'tRNA', 	pattern => '.*', 				color => [TRN],		fullname => 'transfer RNAs', 			drawflag => TRUE},
{type => 'rRNA', 	pattern => '.*', 				color => [RRN],		fullname => 'ribosomal RNAs', 			drawflag => TRUE},
{type => 'rep_origin', 	pattern => '^ori.*', 		color => [ORI],		fullname => 'origin of replication', 	drawflag => TRUE},
{type => 'intron', 	pattern => '.*',				color => [WHITE],	fullname => 'introns', 					drawflag => TRUE},
{type => '_operon_',pattern => '.*',				color => [RED],		fullname => 'polycistronic transcripts', drawflag => FALSE}
);

###############################################################
#                     INSTANCE METHODS                        #
###############################################################
=head1 available Methods

=head2 createMap

 Title   : createMap
 Usage   : $map->createMap(outputfile => "~/foo_map", type => 'jpg', density => '300x300')
 Function: Creates the map and writes it to a file
 Returns : TRUE on success
 Args    : outputfile - path to a writable location where the map will be saved
	type - either jpg, gif, tiff, png or ps (two file will be packed to one zip, containing the actual map file and the respective legend)
	density - resolution of the output - makes sense only for the rasterized image types
	full_legend - set to 1, if you want to list all gene classes in the legend
	(not only those that were actually found in the annotation)

=cut

sub createMap
{
	my ($self, %args) = @_;
    &_check_args(\%args, 'outputfile', 'type', 'density', 'full_legend');
    
    croak('Unknown image type!\n')
      unless (&is_element_of($args{type}, ('ps', 'png', 'jpg', 'tif', 'gif')));
      
    $self->{_outputDPI} = $args{'density'} unless (!defined($args{'density'}));
    
    # disentangle overlapping labels
    $self->_clean_up_labels();
    
    # re-sort feature list descending according to feature sizes 
    @{$self->{_featureList}} = sort { $b->{'extent'} <=> $a->{'extent'} }
      @{$self->{_featureList}};  

    #store PostScript object returned by _create_graph in _psMap
    my ($legendX, $legendY);
    $self->{_psMap} = $self->_create_graph();    
    ($self->{_ps_legend},$legendX, $legendY) = $self->draw_legend($args{full_legend});    

	#$self->{_psMap}->output($args{outputfile} . ".ps");
	my $tmpdir = File::Spec->tmpdir()."/";
    my $tmp = time();
    my $tempfile;

    if ($args{type} eq 'ps')
    {
        $self->{_psMap}->output($args{outputfile} . ".ps");
        $self->{_ps_legend}->output($args{outputfile} . "_legend.ps");
    }
    else
    {
        $tempfile = $tmpdir.$tmp;
    
        #write temporary ps file
        $self->{_psMap}->output("$tempfile.ps");
        $self->{_ps_legend}->output("$tempfile"."_legend.ps");

        # first the map
        my $image = Image::Magick->new();

        $image->Set(
            page    => $self->{_PS_X_SIZE}."x".PS_Y_SIZE,
            density => $self->{_outputDPI},
            units 	=> 'PixelsPerInch,',
            compression => 'LZW' # only needed for tif - seems like it's ignored for other formats
        );

        $image->Read("$tempfile.ps");
        unlink("$tempfile.ps");
        $image->Write($args{outputfile} . "." . $args{type});
        
        # and now the legend...
        my $legend = Image::Magick->new();

        $legend->Set(
            page    => $legendX."x".$legendY,
            density => $self->{_outputDPI},
            units 	=> 'PixelsPerInch,',
            compression => 'LZW' # only needed for tif - seems like it's ignored for other formats
        );
		
		
        $legend->Read("$tempfile"."_legend.ps");
        unlink("$tempfile"."_legend.ps");
        
        $legend->Write($args{outputfile} . "_legend." . $args{type});

    }    #end else
    
    # bundle up everything in a zip archive
    
    #system("zip ".$args{outputfile}.".zip ".$args{outputfile} . "_legend." . $args{type}." ".$args{outputfile} . "." . $args{type}." > $tmpdir"."zip_info");
	#unlink($args{outputfile} . "_legend." . $args{type});
	#unlink($args{outputfile} . "." . $args{type});
	
}

=head2 addRestrictionSites

 Title   : addRestrictionSites
 Usage   : $map->addRestrictionSites('BamHI', 'EcoRI')
 Function: Include the specified restriction sites in the map
 Returns : nothing
 Args    : a list of restriction enzyme names 

=cut

sub addRestrictionSites
{
	my ($self) = shift;
    my @enzymes = @_; # enzymes should be passed as clear names like "BamHI"
        
    my $analysis = Bio::Restriction::Analysis->new(-seq => $self->{'_seqobj'});
    my $lars_favorite_bullshit_enzyme = new Bio::Restriction::Enzyme(-enzyme=>'SapI', -seq=>'GCTCTTCN^NNN');
    $analysis->enzymes($lars_favorite_bullshit_enzyme);
    
    my $RE_report = "-----------------------------------<br>";
    $RE_report .= "Restriction analysis of ".$self->{_seqobj}->desc()."<br>";
    $RE_report .= "Enzymes:<br> ".print_in_html_columns(4,@enzymes)."<br>";
    
    foreach my $enzyme (@enzymes) {
        my $cuts = $analysis->cuts_by_enzyme($enzyme);
        my @positions = $analysis->positions($enzyme);
        
        $RE_report .= "<br><div class=\"enzyme\">$enzyme cuts $cuts times. </div>Positions:<br>".print_in_html_columns(6,@positions)."<br>"
            if ($cuts > 0);
            
        foreach my $cut_site (@positions)  {
       		my $site_name = "$enzyme ($cut_site)";									
            # add an entry to _restrictionSites for each site found
            # restriction sites are added to the beginning of the array
            # to have them drawn behind the features
            unshift @{$self->{_featureList}}, 
            (
                {
	             'name'      		=> $site_name,	             
	             'type'      		=> "_restriction_site_",
	             'strand'    		=> 1,
	             'optimizedPosition'=> undef(),
	             'rotated'			=> TRUE,
	             'labelBox'			=> GeneMap::Plastome::BoundingBox->new( width	=> CHAR_HEIGHT,
	             															height	=> string_width_of($site_name, STRING_WIDTH_SCALING),
	             															x 		=> ($cut_site / $self->{_seqobj}->length()) * $self->{_PS_DRAWABLE_SIZE} + 10,
	             															y		=> RE_Y_POSITION,
	             														  )
	            }
            );
        }
    }    
    return $RE_report;
}


sub setXSize
{
	my $self = shift;
	my $newXsize = shift;
	$self->{_PS_X_SIZE} = $newXsize;
	$self->{_PS_DRAWABLE_SIZE} = $newXsize - 20;
}

=head2 isZoomed

 Title   : isZoomed
 Usage   : $map->isZoomed()
 Function: read out, if the to be drawn map is zoomed
 Returns : TRUE
 Args    : none

=cut

sub isZoomed
{
	my $self = shift;
	return $self->{_is_zoomed};
}

=head2 setZoomRange

 Title   : 
 Usage   : $map->setZoomRange(start => 10000, end => 20000)
 Function: set the range of the molecule, which should be drawn.
 Returns : nothing
 Args    : start, end - define start and end of the fragment to depict.

=cut

sub setZoomRange 
{
	my ($self, %args) = @_;
	&_check_args(\%args, 'start', 'end');
	
	$self->{_zoom_start} = $args{start};
	$self->{_zoom_end} = $args{end};	
	# this requires the internal seqobj to be
	# reset to a truncated version. We also 
	# have to re-run the whole read_contents stuff
	
	my $truncObj = trunc_with_features(	$self->{_seqobj},
										$args{start},
										$args{end});
	
	# overwrite the seqobj with the truncated region?
	# better not - so we can draw maps of different
	# zoom ranges always using the same object.
	
	
	# read in the features from the truncated seqobject
    my ($p_featureList, $p_featureTypes) = $self->_read_contents($truncObj, $self->{_PS_X_SIZE});
    
    # and overwrite the featureList
    $self->{_featureList} = $p_featureList;
    #$self->{_featureTypes} = $p_featureTypes;
    
	
	$self->_setZoomed(TRUE);
}

###############################################################
#                INTERNAL CLASS SUBROUTINES                   #
###############################################################

sub _setZoomed
{
	my $self = shift;
	$self->{_is_zoomed} = shift;
}

sub _read_contents
{
    shift; #discard class
    my $seqobj = shift;
    my $Xsize = shift;
    my (@unsorted_featurelist, @featurelist, @found_types);
    my $feat_name = '';
    my $c         = 0;
    my @feats     = $seqobj->get_SeqFeatures();
    my $counter   = 0;
    my %seen_trnas; 
    my (@found_operons, @large_split_locations);

    # process split locations and add a new feature
    # for each sublocation
    foreach my $feat (@feats)
    {
        # extract the name from the feature
        my $feat_name = _extract_feature_name($feat);
        my $feat_size = abs($feat->end() - $feat->start());
        
        
        # find polycistronic transcripts
        if (($feat->primary_tag() =~ /prim_transcript|mrna/i) ) #&& ($feat_name !~ /rrn/i)
        {
            
            
            #print "prim_transcript: $feat_name-->".$feat->start()."..".$feat->end()."\n";
            foreach my $f (@feats)
            {
                if 	(	($f->start >= $feat->start) and 
                        ($f->end <= $feat->end) and 
                        ($feat_name ne _extract_feature_name($f)) and 
                        ($f->primary_tag() =~ /gene|trna|cds/i) and
                        ($f->strand() == $feat->strand())	)
                {
                    #print "\tis polycistronic, contains: "._extract_feature_name($f)." ".$f->primary_tag()."\n"; 
                    my $operon = Bio::SeqFeature::Generic->new(
                                        -primary        => '_operon_', # our selfmade type
                                        -start          => $feat->start,
                                        -end            => $feat->end
                                        );
                    $seqobj->add_SeqFeature($operon);
                    push @found_operons, $feat;
                    last;                    
                } 							
            }
        }
        
            
        # store all tRNA names in a hash 
        # later we use this hash to exclude trnas
        # that are annotated as 'tRNA' and 'gene'
        $seen_trnas{$feat_name} = 1 if ($feat->primary_tag() =~ /trna/i);
        
        
		# check if it is a split location and process in accordingly
        # we also need to check for absurdely large features here because some
        # of them are annotated as split locations
        if ( $feat->location->isa('Bio::Location::SplitLocationI') && ($feat_size > MIN_SPLIT_SIZE))  
        {
            # proceed without doing anything if all the split locations 
            # lie within the root location
            # this doesn't seem to work as genes that are distributed across the whole
            # maize Chondriome are not drawn anymore - deactivated it
#             if ($feat->location->is_single_sequence()) 
#             {
#                 #print "Location object ".$feat_name.":".$feat->start()."..".$feat->end()." is split but only across a single sequence<br>";
#                 # do not generate sublocation features
#                 #next;
#             }
           
           foreach my $loc ( $feat->location->sub_Location ) 
           {
                # the sublocations are all typed genes....
                my $sub_type = 'gene';
                #print "--->".$loc->strand()."<br>" if ($feat_name =~ /nad5/i);
                my $sub_feat = Bio::SeqFeature::Generic->new(
                                        -tag           => {$sub_type => $feat_name},
                                        -primary        => $feat->primary_tag(), #type
                                        -strand         => $loc->strand(),
                                        -start          => $loc->start,
                                        -end            => $loc->end
                                        );
                # add sublocation to seqobj annotation
                $seqobj->add_SeqFeature($sub_feat);
             
           }# foreach loc
           
           push @large_split_locations, $feat;
        }
    }
    
    # but how do we get rid of the old feature?
    # it has to be deleted otherwise we still draw the long features....
    # we (seem to be able to) do it like this:
    
    # this should flush all features from the seqobj
    my @feat_array = $seqobj->remove_SeqFeatures();
  
    my $e=0;
    while (defined($feat_array[$e]))
    {
        
        # deactivated drawing for polycistronic genes (i.e. operons) unless they
        # are only annotated once
        
        if ((_is_polycistronic_gene($feat_array[$e], @found_operons)) && 
            (!_is_singular_gene_feature($feat_array[$e], @feats))) {
            	$feat_array[$e]->primary_tag('nicht_malen');
            	
            }
        
        # remove unsplit split location features
        if (is_same_feature($feat_array[$e], @large_split_locations)) {      	
        	my @t = splice(@feat_array, $e, 1) if (is_element_of($feat_array[$e], @large_split_locations));        	
        }
        
        $e++;
    }
    
    # and add features back to the seqobj
    my $r = $seqobj->add_SeqFeature(@feat_array);
    
    # the next round has to read in the features again, other- 
    # wise we will not see the changes
    @feats     = $seqobj->get_SeqFeatures();
   
    foreach my $feature (@feats)
    {
        
        my $feat_start  = ($feature->start() / $seqobj->length()) * ($Xsize - 20);
        my $feat_extent = ($feature->end() / $seqobj->length()) * ($Xsize - 20);
        my $feat_strand = $feature->strand();
        my $feat_type   = $feature->primary_tag();
        my $feat_name   = _extract_feature_name($feature);
        my $feat_size = abs($feature->end() - $feature->start());
        
        # nobody needs the source feature. do you?
        next if ($feat_type eq "source");
        
        next if (!defined($feat_strand));
        
        # exclude tRNA genes that are already annotated as tRNA type features
        if (($feat_type =~ /gene/i) && (exists($seen_trnas{$feat_name})))
        {
        	next;
        }
        
        # save the type in @found_types 
        push @found_types, $feat_type;   
        
        # we store all features that do not have an absurd size...
        push @unsorted_featurelist,
          (
            {
             'name'      		=> $feat_name,
             'start'     		=> $feat_start,
             'extent'    		=> $feat_extent,
             'type'      		=> $feat_type,
             'strand'    		=> $feat_strand,
             'contains_others' 	=> undef(),
             'ID' 				=> $counter,
             'optimizedPosition'=> undef(),
             'rotated'			=> FALSE,
             'labelBox'			=> GeneMap::Plastome::BoundingBox->new( height	=> CHAR_HEIGHT,
             															width	=> string_width_of($feat_name, STRING_WIDTH_SCALING),
             															x 		=> (($feat_start + $feat_extent) / 2 + 12.5 ) 
             																		- (string_width_of($feat_name, STRING_WIDTH_SCALING)) / 2,
             															y		=> ($feat_strand == 1) ? DIRECT_LABEL_POS : COMP_LABEL_POS
             														  )
             
            }
          );#
        $counter++;
    }
    
    # sorts features descending according to their length
    # this is necessary to prevent large features from covering smaller overlapping ones
    @featurelist =
      sort { $a->{'start'} <=> $b->{'start'} }
      @unsorted_featurelist;         

    my @drawable_types = &unique(@found_types);

    return (\@featurelist, \@drawable_types);
}# end sub _read_contents


sub _clean_up_labels
{
	my $self = shift;
	
	my @drawable_features;
	
	# filter for non-intron plus strand features and process them subsequently
	for (my $d = 0; $d < $#{$self->{_featureList}}; $d++)  {
		next if (${$self->{_featureList}}[$d]->{type} eq 'intron');
		push @drawable_features, ${$self->{_featureList}}[$d] 
			if (($self->_is_drawable_feature(${$self->{_featureList}}[$d], FALSE)) && (${$self->{_featureList}}[$d]->{strand} == 1));
	}
	my @unopt_direct = _screen_for_overlaps(@drawable_features);
	_relocate_overlapping_labels(1, @drawable_features);
	
	# empty array
	@drawable_features = ();
	
	# do the same for all minus strand features
	for (my $d = 0; $d < $#{$self->{_featureList}}; $d++)  {
		next if (${$self->{_featureList}}[$d]->{type} eq 'intron');
		push @drawable_features, ${$self->{_featureList}}[$d] 
			if (($self->_is_drawable_feature(${$self->{_featureList}}[$d], FALSE)) && (${$self->{_featureList}}[$d]->{strand} == -1));
	}
	
	my @unopt_comp = _screen_for_overlaps(@drawable_features);
	_relocate_overlapping_labels(-1, @drawable_features);
		 	
}

sub _get_drawable_features_on_strand 
{
	print "@_";
	my $strand = shift;
	my @feats = @_;
	my @drawable_features_on_strand;
	
	foreach my $line (@feats){
		push @drawable_features_on_strand, $line if ($line->{strand} == $strand);
		print $line->{strand}."\n";
	}
	print "\n\n----------_>@drawable_features_on_strand";
	return @drawable_features_on_strand;
}

sub _screen_for_overlaps 
{
	
	
	my @drawable_features_on_strand = @_;
	my @unopt_ids;

	for (my $i = 0; $i < $#drawable_features_on_strand; $i++) {
		
		
		
		if ( ($drawable_features_on_strand[$i]->{labelBox}->collides_with(
			$drawable_features_on_strand[$i+1]->{labelBox})) )  {
				
				# Label um 90 grad drehen
				# neue koordinaten in die bounding box packen
				if (!$drawable_features_on_strand[$i]->{rotated}) {
					$drawable_features_on_strand[$i]->{labelBox}->swapDimensions();
					$drawable_features_on_strand[$i]->{rotated} = TRUE;
					$drawable_features_on_strand[$i]->{labelBox}->setX( 
								(($drawable_features_on_strand[$i]->{start} + $drawable_features_on_strand[$i]->{extent}) / 2) - (CHAR_HEIGHT * 0.5) +10);
					
					if ($drawable_features_on_strand[$i]->{strand} == -1) {
						$drawable_features_on_strand[$i]->{labelBox}->setY(($drawable_features_on_strand[$i]->{labelBox}->getY() + CHAR_HEIGHT)
																	- string_width_of($drawable_features_on_strand[$i]->{name}, STRING_WIDTH_SCALING));
					}
				}
				
				# nochmal checken, ob die beiden bbs ueberlappen
				# wenn ja, dann auch das 2. label drehen
				if ( ($drawable_features_on_strand[$i]->{labelBox}->collides_with(
					$drawable_features_on_strand[$i+1]->{labelBox})) ) {						
							
							$drawable_features_on_strand[$i+1]->{labelBox}->swapDimensions();						
							$drawable_features_on_strand[$i+1]->{rotated} = TRUE;
							$drawable_features_on_strand[$i+1]->{labelBox}->setX( 
								((($drawable_features_on_strand[$i+1]->{start} + $drawable_features_on_strand[$i+1]->{extent}) / 2) - (CHAR_HEIGHT * 0.5)) + 10) ; 
							if ($drawable_features_on_strand[$i+1]->{strand} == -1) {
								$drawable_features_on_strand[$i+1]->{labelBox}->setY(($drawable_features_on_strand[$i+1]->{labelBox}->getY() + CHAR_HEIGHT)
																			- string_width_of($drawable_features_on_strand[$i+1]->{name}, STRING_WIDTH_SCALING));
							
						}
					}
				
				# nochmal checken, ob die beiden bbs Ã¼berlappen
				if ( ($drawable_features_on_strand[$i]->{labelBox}->collides_with(
					$drawable_features_on_strand[$i+1]->{labelBox})) ) {						
						
						# store overlapping feature label IDs
						# write the first time both into the array
						if (scalar(@unopt_ids) == 0) {
							push @unopt_ids, $drawable_features_on_strand[$i],
						                 $drawable_features_on_strand[$i+1];
							next
						};
						                 
						# write only if the entry does not exist
						if (!($drawable_features_on_strand[$i]->{name} eq  $unopt_ids[-1]->{name}))
						{	
							push @unopt_ids, $drawable_features_on_strand[$i],
						    $drawable_features_on_strand[$i+1]
						}
						else
						{
							push @unopt_ids, $drawable_features_on_strand[$i+1]
						};
					} 
			}
	}
	return @unopt_ids;	
}

sub _relocate_overlapping_labels 
{
	my $strand = shift;
	my @complete = @_;
	my @exclusive; #an array containing only features with rotated lables -- otherwise non-rotated featurelables could be recognized as colliding, although thought to be in another y-level
	
	foreach my $line (@complete)
	{
		push @exclusive, $line if ($line->{rotated});
	}
	for (my $i = 0; $i <= $#exclusive; $i++) {
		
		for (my $k = -1; abs($k) < (scalar(@exclusive) - $i); $k--) {
			my $abs_k = scalar(@exclusive) + $k; #$k is negative!
				
			if (($exclusive[$k]->{labelBox}->getX() - $exclusive[$i]->{labelBox}->getX()) <= ($abs_k - $i) * CHAR_HEIGHT) {
				
				# recalculate the x positions
				my $needed_space = ($abs_k - $i) * CHAR_HEIGHT;
				# cluster center is first position of cluster + half the distance between start and end
				my $cluster_center = $exclusive[$i]->{labelBox}->getX() + (($exclusive[$abs_k]->{labelBox}->getX() - $exclusive[$i]->{labelBox}->getX()) / 2); 
				my $start_x_pos = $cluster_center - $needed_space / 2;
				
				# write new X and Y pos into all BoundingBoxes of the current cluster
				my $e = 0;
				for (my $d = $i; $d <= $abs_k; $d++) {
					$exclusive[$d]->{labelBox}->setX($start_x_pos + $e * CHAR_HEIGHT);
					$exclusive[$d]->{labelBox}->setY($strand == 1 ? DIRECT_LABEL_POS_SHIFT : COMP_LABEL_POS_SHIFT);
					$e++;
				}
				
				$i = $abs_k;
				next;
			}
		}
	}
}

sub _create_graph
{
	my $self = shift;
	
	#create PostScript object
    my $plastome_ps = new PostScript::Simple(
                                     colour => 1,      
                                     eps    => 0,
                                     units  => "bp",
                                     xsize  => $self->{_PS_X_SIZE},
                                     ysize  => PS_Y_SIZE
                                            );
    $plastome_ps->newpage;
    $plastome_ps->setfont("Helvetica", 10);
    
    foreach my $feature (@{$self->{_featureList}})
    {
    	
    	# try and replace common annotation mistakes to unify the output
        # and ignore genes that are absurdly large and do probably result from
        # annotation errors
        my $feat_name = $feature->{'name'}; 
        
        # draw restriction sites
            if ($feature->{type} eq "_restriction_site_") {
            	draw_restriction_site($plastome_ps, $feature);
#            	print "site: $feature->{name}\n";
            	next;
            }

        if ($self->{'_TIDY'})
        {
            my $feat_size = abs(($feature->{'extent'} - $feature->{'start'}) * ($self->{_seqobj}->length() / $self->{_PS_DRAWABLE_SIZE}));
            next if ($feat_size > MAX_GENE_SIZE);
            $feat_name = GeneMap::Plastome::_tidy_up_name($feat_name) if ($self->{_TIDY});
        }
        
       
        my $draw_color;
        
        # draw everything that is a drawable feature
		if ($self->_is_drawable_feature($feature, \$draw_color))
        {
            # operons will be drawn later
            next if ($feature->{type} eq '_operon_'); 
            
            
            
            
            if ($feature->{'strand'} == 1)
            {
                &_draw_direct_feature(	$plastome_ps,
                						$self->{_seqobj}->length(),  
                						$feature->{'extent'},
                                       	$feature->{'start'},  
                                       	$draw_color, 
                                       	$feature->{'type'});
                                       	
                #print "\t\tPLUS_STRAND: ".$feature->{labelPosition}."\t".$feature->{name}."\t".$feature->{type}."\n";
                &_write_direct_label(	$plastome_ps, 
                						$feat_name, 
                						$feature->{rotated} ? $feature->{labelBox}->getX()+CHAR_HEIGHT : $feature->{labelBox}->getX(),
                						$feature->{rotated}, 
                						$feature->{labelBox}->getY(),
                						$feature->{'start'},
                						$feature->{'extent'})
                  							unless ($feature->{'type'} eq "intron");
                  							
                #push @seen_angles, $ff->{labelPosition};
            }
            else
            {
               &_draw_complementary_feature(	$plastome_ps,
                								$self->{_seqobj}->length(), 
                								$feature->{'extent'},
                                       			$feature->{'start'},  
                                       			$draw_color, 
                                       			$feature->{'type'});
                #print "\t\tMINUS_STRAND: ".$feature->{labelPosition}."\t".$feature->{name}."\t".$feature->{type}."\n";                       			
                &_write_complementary_label(	$plastome_ps, 
                								$feat_name, 
                								$feature->{rotated} ? $feature->{labelBox}->getX()+CHAR_HEIGHT : $feature->{labelBox}->getX(), 
                								$feature->{rotated}, 
                								$feature->{labelBox}->getY(),
                								$feature->{'start'},
                								$feature->{'extent'})
                  									unless ($feature->{'type'} eq "intron");
                  									
                #push @seen_angles, $ff->{labelPosition};
            }
           
            
        }
    }
    # draw main 'strand'
    $plastome_ps->setlinewidth(5);
    $plastome_ps->setcolour('black');
    $plastome_ps->line(10, PS_Y_SIZE * 0.5, $self->{_PS_X_SIZE} - 10, PS_Y_SIZE * 0.5);
    
    #determine the name of the Organelle
    my $mapname = $self->{_displayName};
    $mapname =~ s/\.//; #delete . in filename
    $mapname =~ s/\s\S*,\s.*//;
    
    # general labelling sequence name, organelle type, sequnece length
    
    # insert the name and sequence length
    $plastome_ps->setcolour("black"); 
    $plastome_ps->setfont("Helvetica-BoldOblique", 24);
    $plastome_ps->text({align => "center",}, $self->{_PS_X_SIZE} * 0.5 , PS_Y_SIZE * 0.9, "$mapname");  #main label
    $plastome_ps->setfont("Helvetica", 24);
    
    if ($self->{_organelle} eq "unknown") {
    	$plastome_ps->text({align => "center"}, $self->{_PS_X_SIZE} * 0.5 , PS_Y_SIZE * 0.85, $self->{_seqobj}->display_id());
    } else {
    	$plastome_ps->text({align => "center"}, $self->{_PS_X_SIZE} * 0.5 , PS_Y_SIZE * 0.85, $self->{_organelle}." genome");
    }      
    #$plastome_ps->text({align => "center"}, $self->{_PS_X_SIZE} * 0.5 , PS_Y_SIZE * 0.85, $self->{_organelle}." genome");
    $plastome_ps->setfont("Helvetica", 22);
    
    my $seqlength;
    
    if ($self->isZoomed()) {
    	$seqlength = US_format_number($self->{_zoom_start})." - ".US_format_number($self->{_zoom_end});
    } else {
		$seqlength = US_format_number($self->{_seqobj}->length());
    }
    
    $plastome_ps->text({align => "center"}, ($self->{_PS_X_SIZE}  * 0.5), PS_Y_SIZE * 0.8, "$seqlength bp");
    
    my $scale = 10;
    my $scaletext;
    
    if ($self->{_seqobj}->length() >= 1000) 
    {
    	$scale = 100;
    	$scaletext = "100bp";
    }
    
    if ($self->{_seqobj}->length() >= 10000) 
    {
    	$scale = 1000;
    	$scaletext = "1kb";
    }
    
    if ($self->{_seqobj}->length() >= 100000) 
    {
    	$scale = 10000;
    	$scaletext = "10kb";
    }
    
    # insert scale bar
    my $x = $scale / $self->{_seqobj}->length();
    $plastome_ps->setlinewidth(3);
    $plastome_ps-> line(10, 10, $x * $self->{_PS_DRAWABLE_SIZE} + 10, 10);
    $plastome_ps->setfont("Helvetica", 10);
    $plastome_ps-> text({align => "center"}, $x * $self->{_PS_DRAWABLE_SIZE} * 0.5 + 10, 15, $scaletext);
    
    return $plastome_ps;
}

sub _draw_direct_feature
{
	my ($plastome_ps, $seqlength, $extent, $start, $color, $type) = @_;
    my ($c_R, $c_G, $c_B) = @$color;
    
#    my $pixelrange = $self->{_PS_X_SIZE} -20; # amount of pixels available for whole map
    # this is just a stupid workaround!
    #TODO adjust read_contents to calculate the positions according to the 1180 available PS pixels
    my $bp_pixel = 1; # 1 bp corresponds to this amount of pixels
    
    $plastome_ps->setcolour('black');
    $plastome_ps->box( {filled => 1}, ($start * $bp_pixel)+10, PS_Y_SIZE * 0.5, ($extent * $bp_pixel)+10, PS_Y_SIZE * 0.5 + 25);
    $plastome_ps->setcolour($c_R, $c_G, $c_B);
    $plastome_ps->box( {filled => 1}, ($start * $bp_pixel)+10.25, PS_Y_SIZE * 0.5, ($extent * $bp_pixel)+9.75, PS_Y_SIZE * 0.5 + 24.75);
}

sub _draw_complementary_feature
{
	my ($plastome_ps, $seqlength, $extent, $start, $color, $type) = @_;
    my ($c_R, $c_G, $c_B) = @$color;
    
#    my $pixelrange = $self->{_PS_X_SIZE} -20; # amount of pixels available for whole map
    my $bp_pixel = 1; # 1 bp corresponds to this amount of pixels
    
    $plastome_ps->setcolour('black');
    $plastome_ps->box( {filled => 1}, ($start * $bp_pixel)+10, PS_Y_SIZE * 0.5, ($extent * $bp_pixel)+10, PS_Y_SIZE * 0.5 - 25);
    $plastome_ps->setcolour($c_R, $c_G, $c_B);
    $plastome_ps->box( {filled => 1}, ($start * $bp_pixel)+10.25, PS_Y_SIZE * 0.5, ($extent * $bp_pixel)+9.75, PS_Y_SIZE * 0.5 - 24.75);
}

sub _write_direct_label
{
	
	my $plastome_ps = shift;
    my $name = shift;
    my $labelposition = shift;
    my $rotated = shift;
    my $y = shift;
    my $x_start = shift;
    my $x_end = shift;
    
    
    $plastome_ps->setcolour("black");
    $plastome_ps->setlinewidth(0.25);
    
    $plastome_ps->text({align => "left", rotate => $rotated ? 90 : 0},
                       $labelposition,
                        $y, $name);
    
    my $x_old = ($x_start + $x_end) * 0.5 + 10;
    
#   draw connecting lines between feature and shifted label
	if ($y == DIRECT_LABEL_POS_SHIFT)
	{
		$plastome_ps->line($x_old, DIRECT_LABEL_POS, $x_old, DIRECT_LABEL_POS + 30);
		$plastome_ps->linextend($labelposition - CHAR_HEIGHT * 0.5, $y - CHAR_HEIGHT * 0.5);
	}
}

sub _write_complementary_label
{
	
	
	my $plastome_ps = shift;
    my $name = shift;
    my $labelposition = shift;
    my $rotated = shift;
    my $y = shift;
    my $x_start = shift;
    my $x_end = shift;
    my $align;
    
    if ($y == COMP_LABEL_POS_SHIFT)
    {
    	$align = "right";
    }
    else
    {
    	$align = "left";
    }
    
    
    $plastome_ps->setcolour("black");
    $plastome_ps->setlinewidth(0.25);
    
    
    
    $plastome_ps->text({align => $align, rotate => $rotated ? 90 : 0},
                       $labelposition, $y, $name);#$rotated ? $y + (CHAR_HEIGHT - 2.5) : $y

    my $x_old = ($x_start + $x_end) * 0.5 + 10;
    
#   draw connecting lines between feature and shifted label
	if ($y == COMP_LABEL_POS_SHIFT)
	{
		$plastome_ps->line($x_old, COMP_LABEL_POS + CHAR_HEIGHT, $x_old, COMP_LABEL_POS - 30 + CHAR_HEIGHT);
		$plastome_ps->linextend($labelposition - CHAR_HEIGHT * 0.5, $y + CHAR_HEIGHT * 0.5);
	}                  
}

sub _is_drawable_feature
{
	my ($self, $test, $p_color) = @_;
	

	
	for (my $d = 0; $d <= $#{$self->{'_drawableFeatures'}};$d++)
			{
				if (($test->{type} =~ /${$self->{_drawableFeatures}}[$d]->{type}/i) and 
				($test->{name} =~ /${$self->{_drawableFeatures}}[$d]->{pattern}/i) and 
				(${$self->{_drawableFeatures}}[$d]->{drawflag})) 
				{
				${$p_color} = ${$self->{_drawableFeatures}}[$d]->{color} unless (!$p_color);
				return TRUE;
				}		 
			}
	 return FALSE;

}

sub _extract_feature_name
{
	 my $feat = shift;	 
	 my $feat_name;
#      my @tags = $feat->get_all_tags();
     
     if (($feat->primary_tag() eq "CDS") and ($feat->has_tag('note')) and ($feat->has_tag('gene')))
     {
#      	print "vielleicht ORF<br>";
     	my @notes = $feat->get_tag_values('note');
     	foreach my $note (@notes) 
     	{
#      		print $note."<br>";
     		if ($note =~ /(^orf\s*\d+.*)/i) 
     		{
#      			print $&."<br>";
     			return $note
     		};     		
     	}
     }
     
     if ($feat->has_tag('gene'))
     {
         my @names = $feat->get_tag_values('gene');
         foreach my $name (@names) { $feat_name = $name }
     }
     elsif ($feat->has_tag('label'))
     {
         my @notes = $feat->get_tag_values('label');
         foreach my $note (@notes) { $feat_name = $note }
     }
     elsif ($feat->has_tag('note'))
     {
         my @notes = $feat->get_tag_values('note');
         foreach my $note (@notes) { $feat_name = $note }
     }
     elsif ($feat->has_tag('locus_tag'))
     {
         my @notes = $feat->get_tag_values('locus_tag');
         foreach my $note (@notes) { $feat_name = $note }
     }
     elsif ($feat->has_tag('product'))
     {
         my @notes = $feat->get_tag_values('product');
         foreach my $note (@notes) { $feat_name = $note }

     }
     else
     {
         $feat_name = 'N/D';
     }
     return $feat_name;
}

sub _is_singular_gene_feature
{
    my $feature = shift;
    my $feature_name = _extract_feature_name($feature);
    my @feats = @_;
    foreach my $f (@feats)
    {
        if (($f->start != $feature->start) &&
            ($f->end != $feature->end) &&
            ($f->primary_tag eq 'gene') &&
            ($feature_name eq _extract_feature_name($f)))
        {
            #print "$feature_name is not a singular gene\n";
            return FALSE;
        }
    }
    return TRUE;
}

sub _is_polycistronic_gene
{
    my $test = shift; 
    my @operons  = @_;
    foreach my $o (@operons)
    {
        if (($o->start == $test->start) &&
            ($o->end == $test->end) &&
            ($test->primary_tag ne '_operon_'))
        {
            return TRUE;
        }
    }
    return FALSE;
}

sub draw_legend
{
	my $self = shift;
	my $fullLegend = shift;
	my @legend = reverse @{$self->{'_drawableFeatures'}};
	my $LEGEND_X_SIZE = 300;
	my $LEGEND_Y_SIZE = 20;
	
	foreach my $entry (@legend) {		
		if ($fullLegend) {
			$LEGEND_Y_SIZE += 15;
			next;
		} elsif ($entry->{drawflag}) {
			$LEGEND_Y_SIZE += 15
		}
	} 
	
	
	
	#create PostScript object
    my $legend_ps = new PostScript::Simple(
                                     colour => 1,      
                                     eps    => 0,
                                     units  => "bp",
                                     xsize  => $LEGEND_X_SIZE,
                                     ysize  => $LEGEND_Y_SIZE
                                            );
    $legend_ps -> newpage;
    $legend_ps -> setfont("Helvetica", 10);
    
    my $c = 0;
    for (my $f = 0 ; $f <= $#legend ; $f++)
    {
        unless (defined($fullLegend)) {
        	next if (   ($legend[$f]->{'fullname'} eq '') or (!$legend[$f]->{'drawflag'}));
#          	next if (!exists($foundFeatureClasses{$legend[$f]->{'fullname'}})) ;
        }
        # if there is no feature of this class
        # in the annotation don't include it in
#         # the legend!
#         unless (defined($fullLegend)) {
#         	
#        	}
        
        $legend_ps->setcolour('black');
        $legend_ps->setlinewidth(2);
        $legend_ps->box(10, 10 + ($c * 15), 20, 20 + ($c * 15));
        $legend_ps->text(25, 11 + ($c * 15), $legend[$f]->{'fullname'});
        $legend_ps->setcolour(@{$legend[$f]->{'color'}});
        $legend_ps->box({filled => 1},
                          10.1, 10.1 + ($c * 15),
                          19.9, 19.9 + ($c * 15));
        $c++;
    }
    return $legend_ps, $LEGEND_X_SIZE, $LEGEND_Y_SIZE;	
}

sub draw_restriction_site
{	

	my $ps_map = shift;
	my $site = shift;
	$ps_map->setcolour(RE_LINE_COLOR);
	$ps_map->line(			$site->{labelBox}->getX(), 
							RE_Y_POSITION - CHAR_HEIGHT * 0.5,
							$site->{labelBox}->getX(),
							PS_Y_SIZE * 0.5 
						);
	$ps_map->setcolour('black');
	$ps_map->text(		{rotate => 90, align => 'left'},
							$site->{labelBox}->getX() + (CHAR_HEIGHT * 0.5),
							RE_Y_POSITION,
							$site->{name}
						 );
	
	
}

1;
